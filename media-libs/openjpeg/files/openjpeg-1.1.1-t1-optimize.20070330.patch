diff -ur OpenJPEG.orig/libopenjpeg/t1.c OpenJPEG/libopenjpeg/t1.c
--- OpenJPEG.orig/libopenjpeg/t1.c	2007-02-21 01:57:27.000000000 -0600
+++ OpenJPEG/libopenjpeg/t1.c	2007-03-30 01:21:48.000000000 -0500
@@ -43,7 +43,7 @@
 static int t1_getspb(opj_t1_t *t1, int f);
 static int t1_getnmsedec_sig(opj_t1_t *t1, int x, int bitpos);
 static int t1_getnmsedec_ref(opj_t1_t *t1, int x, int bitpos);
-static void t1_updateflags(int *fp, int s);
+static void t1_updateflags(int *fp, int s, int w);
 /**
 Encode significant pass
 */
@@ -55,11 +55,11 @@
 /**
 Encode significant pass
 */
-static void t1_enc_sigpass(opj_t1_t *t1, int w, int h, int bpno, int orient, int *nmsedec, char type, int cblksty);
+static void t1_enc_sigpass(opj_t1_t *t1, int bpno, int orient, int *nmsedec, char type, int cblksty);
 /**
 Decode significant pass
 */
-static void t1_dec_sigpass(opj_t1_t *t1, int w, int h, int bpno, int orient, char type, int cblksty);
+static void t1_dec_sigpass(opj_t1_t *t1, int bpno, int orient, char type, int cblksty);
 /**
 Encode refinement pass
 */
@@ -71,11 +71,11 @@
 /**
 Encode refinement pass
 */
-static void t1_enc_refpass(opj_t1_t *t1, int w, int h, int bpno, int *nmsedec, char type, int cblksty);
+static void t1_enc_refpass(opj_t1_t *t1, int bpno, int *nmsedec, char type, int cblksty);
 /**
 Decode refinement pass
 */
-static void t1_dec_refpass(opj_t1_t *t1, int w, int h, int bpno, char type, int cblksty);
+static void t1_dec_refpass(opj_t1_t *t1, int bpno, char type, int cblksty);
 /**
 Encode clean-up pass
 */
@@ -87,11 +87,11 @@
 /**
 Encode clean-up pass
 */
-static void t1_enc_clnpass(opj_t1_t *t1, int w, int h, int bpno, int orient, int *nmsedec, int cblksty);
+static void t1_enc_clnpass(opj_t1_t *t1, int bpno, int orient, int *nmsedec, int cblksty);
 /**
 Decode clean-up pass
 */
-static void t1_dec_clnpass(opj_t1_t *t1, int w, int h, int bpno, int orient, int cblksty);
+static void t1_dec_clnpass(opj_t1_t *t1, int bpno, int orient, int cblksty);
 static double t1_getwmsedec(int nmsedec, int compno, int level, int orient, int bpno, int qmfbid, double stepsize, int numcomps);
 /**
 Encode 1 code-block
@@ -164,9 +164,15 @@
     return t1->lut_nmsedec_ref0[x & ((1 << T1_NMSEDEC_BITS) - 1)];
 }
 
-static void t1_updateflags(int *fp, int s) {
+static void t1_updateflags(int *fp, int s, int w) {
+#ifdef DYNAMIC_T1
+	int *np = fp - (w + 2);
+	int *sp = fp + (w + 2);
+#else
 	int *np = fp - (T1_MAXCBLKW + 2);
 	int *sp = fp + (T1_MAXCBLKW + 2);
+#endif
+
 	np[-1] |= T1_SIG_SE;
 	np[1] |= T1_SIG_SW;
 	sp[-1] |= T1_SIG_NE;
@@ -183,7 +189,17 @@
 	}
 }
 
-static void t1_enc_sigpass_step(opj_t1_t *t1, int *fp, int *dp, int orient, int bpno, int one, int *nmsedec, char type, int vsc) {
+static void t1_enc_sigpass_step(
+		opj_t1_t *t1,
+		int *fp,
+		int *dp,
+		int orient,
+		int bpno,
+		int one,
+		int *nmsedec,
+		char type,
+		int vsc)
+{
 	int v, flag;
 	
 	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
@@ -208,7 +224,7 @@
 				mqc_setcurctx(mqc, t1_getctxno_sc(t1, flag));
 				mqc_encode(mqc, v ^ t1_getspb(t1, flag));
 			}
-			t1_updateflags(fp, v);
+			t1_updateflags(fp, v, t1->w);
 			*fp |= T1_SIG;
 		}
 		*fp |= T1_VISIT;
@@ -227,7 +243,7 @@
 			if (raw_decode(raw)) {
 				v = raw_decode(raw);	/* ESSAI */
 				*dp = v ? -oneplushalf : oneplushalf;
-				t1_updateflags(fp, v);
+				t1_updateflags(fp, v, t1->w);
 				*fp |= T1_SIG;
 			}
 		} else {
@@ -236,7 +252,7 @@
 				mqc_setcurctx(mqc, t1_getctxno_sc(t1, flag));
 				v = mqc_decode(mqc) ^ t1_getspb(t1, flag);
 				*dp = v ? -oneplushalf : oneplushalf;
-				t1_updateflags(fp, v);
+				t1_updateflags(fp, v, t1->w);
 				*fp |= T1_SIG;
 			}
 		}
@@ -244,30 +260,53 @@
 	}
 }				/* VSC and  BYPASS by Antonin */
 
-static void t1_enc_sigpass(opj_t1_t *t1, int w, int h, int bpno, int orient, int *nmsedec, char type, int cblksty) {
+static void t1_enc_sigpass(
+		opj_t1_t *t1,
+		int bpno,
+		int orient,
+		int *nmsedec,
+		char type,
+		int cblksty)
+{
 	int i, j, k, one, vsc;
 	*nmsedec = 0;
 	one = 1 << (bpno + T1_NMSEDEC_FRACBITS);
-	for (k = 0; k < h; k += 4) {
-		for (i = 0; i < w; i++) {
-			for (j = k; j < k + 4 && j < h; j++) {
-				vsc = ((cblksty & J2K_CCP_CBLKSTY_VSC) && (j == k + 3 || j == h - 1)) ? 1 : 0;
-				t1_enc_sigpass_step(t1, &t1->flags[1 + j][1 + i], &t1->data[j][i], orient, bpno, one, nmsedec, type, vsc);
+	for (k = 0; k < t1->h; k += 4) {
+		for (i = 0; i < t1->w; ++i) {
+			for (j = k; j < k + 4 && j < t1->h; ++j) {
+				vsc = ((cblksty & J2K_CCP_CBLKSTY_VSC) && (j == k + 3 || j == t1->h - 1)) ? 1 : 0;
+				t1_enc_sigpass_step(
+						t1,
+						&MACRO_t1_flags(1 + j,1 + i),
+						&MACRO_t1_data(j,i),
+						orient,
+						bpno,
+						one,
+						nmsedec,
+						type,
+						vsc);
 			}
 		}
 	}
 }
 
-static void t1_dec_sigpass(opj_t1_t *t1, int w, int h, int bpno, int orient, char type, int cblksty) {
+static void t1_dec_sigpass(opj_t1_t *t1, int bpno, int orient, char type, int cblksty) {
 	int i, j, k, one, half, oneplushalf, vsc;
 	one = 1 << bpno;
 	half = one >> 1;
 	oneplushalf = one | half;
-	for (k = 0; k < h; k += 4) {
-		for (i = 0; i < w; i++) {
-			for (j = k; j < k + 4 && j < h; j++) {
-				vsc = ((cblksty & J2K_CCP_CBLKSTY_VSC) && (j == k + 3 || j == h - 1)) ? 1 : 0;
-				t1_dec_sigpass_step(t1, &t1->flags[1 + j][1 + i], &t1->data[j][i], orient, oneplushalf, type, vsc);
+	for (k = 0; k < t1->h; k += 4) {
+		for (i = 0; i < t1->w; ++i) {
+			for (j = k; j < k + 4 && j < t1->h; ++j) {
+				vsc = ((cblksty & J2K_CCP_CBLKSTY_VSC) && (j == k + 3 || j == t1->h - 1)) ? 1 : 0;
+				t1_dec_sigpass_step(
+						t1,
+						&MACRO_t1_flags(1 + j,1 + i),
+						&MACRO_t1_data(j,i),
+						orient,
+						oneplushalf,
+						type,
+						vsc);
 			}
 		}
 	}
@@ -314,37 +353,68 @@
 	}
 }				/* VSC and  BYPASS by Antonin  */
 
-static void t1_enc_refpass(opj_t1_t *t1, int w, int h, int bpno, int *nmsedec, char type, int cblksty) {
+static void t1_enc_refpass(
+		opj_t1_t *t1,
+		int bpno,
+		int *nmsedec,
+		char type,
+		int cblksty)
+{
 	int i, j, k, one, vsc;
 	*nmsedec = 0;
 	one = 1 << (bpno + T1_NMSEDEC_FRACBITS);
-	for (k = 0; k < h; k += 4) {
-		for (i = 0; i < w; i++) {
-			for (j = k; j < k + 4 && j < h; j++) {
-				vsc = ((cblksty & J2K_CCP_CBLKSTY_VSC) && (j == k + 3 || j == h - 1)) ? 1 : 0;
-				t1_enc_refpass_step(t1, &t1->flags[1 + j][1 + i], &t1->data[j][i], bpno, one, nmsedec, type, vsc);
+	for (k = 0; k < t1->h; k += 4) {
+		for (i = 0; i < t1->w; ++i) {
+			for (j = k; j < k + 4 && j < t1->h; ++j) {
+				vsc = ((cblksty & J2K_CCP_CBLKSTY_VSC) && (j == k + 3 || j == t1->h - 1)) ? 1 : 0;
+				t1_enc_refpass_step(
+						t1,
+						&MACRO_t1_flags(1 + j,1 + i),
+						&MACRO_t1_data(j,i),
+						bpno,
+						one,
+						nmsedec,
+						type,
+						vsc);
 			}
 		}
 	}
 }
 
-static void t1_dec_refpass(opj_t1_t *t1, int w, int h, int bpno, char type, int cblksty) {
+static void t1_dec_refpass(opj_t1_t *t1, int bpno, char type, int cblksty) {
 	int i, j, k, one, poshalf, neghalf;
 	int vsc;
 	one = 1 << bpno;
 	poshalf = one >> 1;
 	neghalf = bpno > 0 ? -poshalf : -1;
-	for (k = 0; k < h; k += 4) {
-		for (i = 0; i < w; i++) {
-			for (j = k; j < k + 4 && j < h; j++) {
-				vsc = ((cblksty & J2K_CCP_CBLKSTY_VSC) && (j == k + 3 || j == h - 1)) ? 1 : 0;
-				t1_dec_refpass_step(t1, &t1->flags[1 + j][1 + i], &t1->data[j][i], poshalf, neghalf, type, vsc);
+	for (k = 0; k < t1->h; k += 4) {
+		for (i = 0; i < t1->w; ++i) {
+			for (j = k; j < k + 4 && j < t1->h; ++j) {
+				vsc = ((cblksty & J2K_CCP_CBLKSTY_VSC) && (j == k + 3 || j == t1->h - 1)) ? 1 : 0;
+				t1_dec_refpass_step(
+						t1,
+						&MACRO_t1_flags(1 + j,1 + i),
+						&MACRO_t1_data(j,i),
+						poshalf,
+						neghalf,
+						type,
+						vsc);
 			}
 		}
 	}
 }				/* VSC and  BYPASS by Antonin */
 
-static void t1_enc_clnpass_step(opj_t1_t *t1, int *fp, int *dp, int orient, int bpno, int one, int *nmsedec, int partial, int vsc) {
+static void t1_enc_clnpass_step(
+		opj_t1_t *t1,
+		int *fp,
+		int *dp,
+		int orient,
+		int bpno,
+		int one,
+		int *nmsedec,
+		int partial,
+		int vsc)
+{
 	int v, flag;
 	
 	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
@@ -363,14 +433,22 @@
 			mqc_setcurctx(mqc, t1_getctxno_sc(t1, flag));
 			v = *dp < 0 ? 1 : 0;
 			mqc_encode(mqc, v ^ t1_getspb(t1, flag));
-			t1_updateflags(fp, v);
+			t1_updateflags(fp, v, t1->w);
 			*fp |= T1_SIG;
 		}
 	}
 	*fp &= ~T1_VISIT;
 }
 
-static void t1_dec_clnpass_step(opj_t1_t *t1, int *fp, int *dp, int orient, int oneplushalf, int partial, int vsc) {
+static void t1_dec_clnpass_step(
+		opj_t1_t *t1,
+		int *fp,
+		int *dp,
+		int orient,
+		int oneplushalf,
+		int partial,
+		int vsc)
+{
 	int v, flag;
 	
 	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
@@ -386,41 +464,47 @@
 			mqc_setcurctx(mqc, t1_getctxno_sc(t1, flag));
 			v = mqc_decode(mqc) ^ t1_getspb(t1, flag);
 			*dp = v ? -oneplushalf : oneplushalf;
-			t1_updateflags(fp, v);
+			t1_updateflags(fp, v, t1->w);
 			*fp |= T1_SIG;
 		}
 	}
 	*fp &= ~T1_VISIT;
 }				/* VSC and  BYPASS by Antonin */
 
-static void t1_enc_clnpass(opj_t1_t *t1, int w, int h, int bpno, int orient, int *nmsedec, int cblksty) {
+static void t1_enc_clnpass(
+		opj_t1_t *t1,
+		int bpno,
+		int orient,
+		int *nmsedec,
+		int cblksty)
+{
 	int i, j, k, one, agg, runlen, vsc;
 	
 	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
 	
 	*nmsedec = 0;
 	one = 1 << (bpno + T1_NMSEDEC_FRACBITS);
-	for (k = 0; k < h; k += 4) {
-		for (i = 0; i < w; i++) {
-			if (k + 3 < h) {
+	for (k = 0; k < t1->h; k += 4) {
+		for (i = 0; i < t1->w; ++i) {
+			if (k + 3 < t1->h) {
 				if (cblksty & J2K_CCP_CBLKSTY_VSC) {
-					agg = !(t1->flags[1 + k][1 + i] & (T1_SIG | T1_VISIT | T1_SIG_OTH)
-						|| t1->flags[1 + k + 1][1 + i] & (T1_SIG | T1_VISIT | T1_SIG_OTH)
-						|| t1->flags[1 + k + 2][1 + i] & (T1_SIG | T1_VISIT | T1_SIG_OTH)
-						|| (t1->flags[1 + k + 3][1 + i] 
+					agg = !(MACRO_t1_flags(1 + k,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| MACRO_t1_flags(1 + k + 1,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| MACRO_t1_flags(1 + k + 2,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| (MACRO_t1_flags(1 + k + 3,1 + i) 
 						& (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW |	T1_SGN_S))) & (T1_SIG | T1_VISIT | T1_SIG_OTH));
 				} else {
-					agg = !(t1->flags[1 + k][1 + i] & (T1_SIG | T1_VISIT | T1_SIG_OTH)
-						|| t1->flags[1 + k + 1][1 + i] & (T1_SIG | T1_VISIT | T1_SIG_OTH)
-						|| t1->flags[1 + k + 2][1 + i] & (T1_SIG | T1_VISIT | T1_SIG_OTH)
-						|| t1->flags[1 + k + 3][1 + i] & (T1_SIG | T1_VISIT | T1_SIG_OTH));
+					agg = !(MACRO_t1_flags(1 + k,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| MACRO_t1_flags(1 + k + 1,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| MACRO_t1_flags(1 + k + 2,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| MACRO_t1_flags(1 + k + 3,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH));
 				}
 			} else {
 				agg = 0;
 			}
 			if (agg) {
-				for (runlen = 0; runlen < 4; runlen++) {
-					if (int_abs(t1->data[k + runlen][i]) & one)
+				for (runlen = 0; runlen < 4; ++runlen) {
+					if (int_abs(MACRO_t1_data(k + runlen,i)) & one)
 						break;
 				}
 				mqc_setcurctx(mqc, T1_CTXNO_AGG);
@@ -434,15 +518,29 @@
 			} else {
 				runlen = 0;
 			}
-			for (j = k + runlen; j < k + 4 && j < h; j++) {
-				vsc = ((cblksty & J2K_CCP_CBLKSTY_VSC) && (j == k + 3 || j == h - 1)) ? 1 : 0;
-				t1_enc_clnpass_step(t1, &t1->flags[1 + j][1 + i], &t1->data[j][i], orient, bpno, one, nmsedec, agg && (j == k + runlen), vsc);
+			for (j = k + runlen; j < k + 4 && j < t1->h; ++j) {
+				vsc = ((cblksty & J2K_CCP_CBLKSTY_VSC) && (j == k + 3 || j == t1->h - 1)) ? 1 : 0;
+				t1_enc_clnpass_step(
+						t1,
+						&MACRO_t1_flags(1 + j,1 + i),
+						&MACRO_t1_data(j,i),
+						orient,
+						bpno,
+						one,
+						nmsedec,
+						agg && (j == k + runlen),
+						vsc);
 			}
 		}
 	}
 }
 
-static void t1_dec_clnpass(opj_t1_t *t1, int w, int h, int bpno, int orient, int cblksty) {
+static void t1_dec_clnpass(
+		opj_t1_t *t1,
+		int bpno,
+		int orient,
+		int cblksty)
+{
 	int i, j, k, one, half, oneplushalf, agg, runlen, vsc;
 	int segsym = cblksty & J2K_CCP_CBLKSTY_SEGSYM;
 	
@@ -451,20 +549,20 @@
 	one = 1 << bpno;
 	half = one >> 1;
 	oneplushalf = one | half;
-	for (k = 0; k < h; k += 4) {
-		for (i = 0; i < w; i++) {
-			if (k + 3 < h) {
+	for (k = 0; k < t1->h; k += 4) {
+		for (i = 0; i < t1->w; ++i) {
+			if (k + 3 < t1->h) {
 				if (cblksty & J2K_CCP_CBLKSTY_VSC) {
-					agg = !(t1->flags[1 + k][1 + i] & (T1_SIG | T1_VISIT | T1_SIG_OTH)
-						|| t1->flags[1 + k + 1][1 + i] & (T1_SIG | T1_VISIT | T1_SIG_OTH)
-						|| t1->flags[1 + k + 2][1 + i] & (T1_SIG | T1_VISIT | T1_SIG_OTH)
-						|| (t1->flags[1 + k + 3][1 + i] 
+					agg = !(MACRO_t1_flags(1 + k,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| MACRO_t1_flags(1 + k + 1,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| MACRO_t1_flags(1 + k + 2,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| (MACRO_t1_flags(1 + k + 3,1 + i) 
 						& (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW |	T1_SGN_S))) & (T1_SIG | T1_VISIT | T1_SIG_OTH));
 				} else {
-					agg = !(t1->flags[1 + k][1 + i] & (T1_SIG | T1_VISIT | T1_SIG_OTH)
-						|| t1->flags[1 + k + 1][1 + i] & (T1_SIG | T1_VISIT | T1_SIG_OTH)
-						|| t1->flags[1 + k + 2][1 + i] & (T1_SIG | T1_VISIT | T1_SIG_OTH)
-						|| t1->flags[1 + k + 3][1 + i] & (T1_SIG | T1_VISIT | T1_SIG_OTH));
+					agg = !(MACRO_t1_flags(1 + k,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| MACRO_t1_flags(1 + k + 1,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| MACRO_t1_flags(1 + k + 2,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| MACRO_t1_flags(1 + k + 3,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH));
 				}
 			} else {
 				agg = 0;
@@ -480,9 +578,16 @@
 			} else {
 				runlen = 0;
 			}
-			for (j = k + runlen; j < k + 4 && j < h; j++) {
-				vsc = ((cblksty & J2K_CCP_CBLKSTY_VSC) && (j == k + 3 || j == h - 1)) ? 1 : 0;
-				t1_dec_clnpass_step(t1, &t1->flags[1 + j][1 + i], &t1->data[j][i], orient, oneplushalf, agg && (j == k + runlen), vsc);
+			for (j = k + runlen; j < k + 4 && j < t1->h; ++j) {
+				vsc = ((cblksty & J2K_CCP_CBLKSTY_VSC) && (j == k + 3 || j == t1->h - 1)) ? 1 : 0;
+				t1_dec_clnpass_step(
+						t1,
+						&MACRO_t1_flags(1 + j,1 + i),
+						&MACRO_t1_data(j,i),
+						orient,
+						oneplushalf,
+						agg && (j == k + runlen),
+						vsc);
 			}
 		}
 	}
@@ -519,9 +624,19 @@
 }
 
 /** mod fixed_quality */
-static void t1_encode_cblk(opj_t1_t *t1, opj_tcd_cblk_t * cblk, int orient, int compno, int level, int qmfbid, double stepsize, int cblksty, int numcomps, opj_tcd_tile_t * tile) {
+static void t1_encode_cblk(
+		opj_t1_t *t1,
+		opj_tcd_cblk_t * cblk,
+		int orient,
+		int compno,
+		int level,
+		int qmfbid,
+		double stepsize,
+		int cblksty,
+		int numcomps,
+		opj_tcd_tile_t * tile)
+{
 	int i, j;
-	int w, h;
 	int passno;
 	int bpno, passtype;
 	int max;
@@ -530,26 +645,25 @@
 	char type = T1_TYPE_MQ;
 	
 	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
-	
-	w = cblk->x1 - cblk->x0;
-	h = cblk->y1 - cblk->y0;
-	
+
+	t1->w = cblk->x1 - cblk->x0;
+	t1->h = cblk->y1 - cblk->y0;
+
 	max = 0;
-	for (j = 0; j < h; j++) {
-		for (i = 0; i < w; i++) {
-			max = int_max(max, int_abs(t1->data[j][i]));
+	for (j = 0; j < t1->h; ++j) {
+		for (i = 0; i < t1->w; ++i) {
+			max = int_max(max, int_abs(MACRO_t1_data(j,i)));
 		}
 	}
-	
+
 	cblk->numbps = max ? (int_floorlog2(max) + 1) - T1_NMSEDEC_FRACBITS : 0;
-	
-	/* Changed by Dmitry Kolyadin */
-	for (i = 0; i <= w; i++) {
-		for (j = 0; j <= h; j++) {
-			t1->flags[j][i] = 0;
-		}
+
+#ifndef DYNAMIC_T1
+	for (i = 0; i <= t1->h; ++i) {
+		memset(&t1->flags[i],0,sizeof(int)*((t1->w)+1));
 	}
-	
+#endif
+
 	bpno = cblk->numbps - 1;
 	passtype = 2;
 	
@@ -559,20 +673,20 @@
 	mqc_setstate(mqc, T1_CTXNO_ZC, 0, 4);
 	mqc_init_enc(mqc, cblk->data);
 	
-	for (passno = 0; bpno >= 0; passno++) {
+	for (passno = 0; bpno >= 0; ++passno) {
 		opj_tcd_pass_t *pass = &cblk->passes[passno];
 		int correction = 3;
 		type = ((bpno < (cblk->numbps - 4)) && (passtype < 2) && (cblksty & J2K_CCP_CBLKSTY_LAZY)) ? T1_TYPE_RAW : T1_TYPE_MQ;
 		
 		switch (passtype) {
 			case 0:
-				t1_enc_sigpass(t1, w, h, bpno, orient, &nmsedec, type, cblksty);
+				t1_enc_sigpass(t1, bpno, orient, &nmsedec, type, cblksty);
 				break;
 			case 1:
-				t1_enc_refpass(t1, w, h, bpno, &nmsedec, type, cblksty);
+				t1_enc_refpass(t1, bpno, &nmsedec, type, cblksty);
 				break;
 			case 2:
-				t1_enc_clnpass(t1, w, h, bpno, orient, &nmsedec, cblksty);
+				t1_enc_clnpass(t1, bpno, orient, &nmsedec, cblksty);
 				/* code switch SEGMARK (i.e. SEGSYM) */
 				if (cblksty & J2K_CCP_CBLKSTY_SEGSYM)
 					mqc_segmark_enc(mqc);
@@ -642,8 +756,59 @@
 	cblk->totalpasses = passno;
 }
 
-static void t1_decode_cblk(opj_t1_t *t1, opj_tcd_cblk_t * cblk, int orient, int roishift, int cblksty) {
-	int i, j, w, h;
+#ifdef DYNAMIC_T1
+int assure_buffers(
+		opj_t1_t *t1,
+		int w,
+		int h)
+{
+	size_t datasize;
+	size_t flagssize;
+
+	datasize=sizeof(int)*w*h;
+	flagssize=sizeof(int)*(h+2)*(h+2);
+	//printf("w=%i h=%i\n",w,h);
+
+	if(datasize > t1->datasize){
+		if(t1->data != NULL){
+			printf("Reallocating t1->data: datasize=%i\n",datasize);
+			opj_free(t1->data);
+		}
+		t1->data=opj_malloc(datasize);
+		if(t1->data == NULL){
+			printf("Reallocating t1->data FAILED!\n");
+			return;
+		}
+		t1->datasize=datasize;
+	}
+	memset(t1->data,0,datasize);
+
+	if(flagssize > t1->flagssize){
+		if(t1->flags != NULL){
+			printf("Reallocating t1->flags: flagssize=%i\n",flagssize);
+			opj_free(t1->flags);
+		}
+		t1->flags=opj_malloc(flagssize);
+		if(t1->flags == NULL){
+			printf("Reallocating t1->flags FAILED!\n");
+			return;
+		}
+		t1->flagssize=flagssize;
+	}
+	memset(t1->flags,0,flagssize);
+
+	t1->w=w;
+	t1->h=h;
+}
+#endif
+
+static void t1_decode_cblk(
+		opj_t1_t *t1,
+		opj_tcd_cblk_t *cblk,
+		int orient,
+		int roishift,
+		int cblksty)
+{
 	int bpno, passtype;
 	int segno, passno;
 	char type = T1_TYPE_MQ; /* BYPASS mode */
@@ -651,32 +816,35 @@
 	opj_raw_t *raw = t1->raw;	/* RAW component */
 	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
 	
-	w = cblk->x1 - cblk->x0;
-	h = cblk->y1 - cblk->y0;
-	
-	/* Changed by Dmitry Kolyadin */
-	for (j = 0; j <= h; j++) {
-		for (i = 0; i <= w; i++) {
-			t1->flags[j][i] = 0;
-		}
+#ifndef DYNAMIC_T1
+	int i;
+
+	t1->w=cblk->x1 - cblk->x0;
+	t1->h=cblk->y1 - cblk->y0;
+
+	for (i = 0; i < t1->h; ++i) {
+		memset(&t1->data[i],0,sizeof(int)*(t1->w));
 	}
-	
-	/* Changed by Dmitry Kolyadin */
-	for (i = 0; i < w; i++) {
-		for (j = 0; j < h; j++){
-			t1->data[j][i] = 0;
-		}
+
+	for (i = 0; i <= t1->h; ++i) {
+		memset(&t1->flags[i],0,sizeof(int)*((t1->w)+1));
 	}
-	
+#else
+	assure_buffers(
+			t1,
+			cblk->x1 - cblk->x0,
+			cblk->y1 - cblk->y0);
+#endif
+
 	bpno = roishift + cblk->numbps - 1;
 	passtype = 2;
-	
+
 	mqc_resetstates(mqc);
 	mqc_setstate(mqc, T1_CTXNO_UNI, 0, 46);
 	mqc_setstate(mqc, T1_CTXNO_AGG, 0, 3);
 	mqc_setstate(mqc, T1_CTXNO_ZC, 0, 4);
-	
-	for (segno = 0; segno < cblk->numsegs; segno++) {
+
+	for (segno = 0; segno < cblk->numsegs; ++segno) {
 		opj_tcd_seg_t *seg = &cblk->segs[segno];
 		
 		/* BYPASS mode */
@@ -687,16 +855,16 @@
 			mqc_init_dec(mqc, seg->data, seg->len);
 		}
 		
-		for (passno = 0; passno < seg->numpasses; passno++) {
+		for (passno = 0; passno < seg->numpasses; ++passno) {
 			switch (passtype) {
 				case 0:
-					t1_dec_sigpass(t1, w, h, bpno+1, orient, type, cblksty);
+					t1_dec_sigpass(t1, bpno+1, orient, type, cblksty);
 					break;
 				case 1:
-					t1_dec_refpass(t1, w, h, bpno+1, type, cblksty);
+					t1_dec_refpass(t1, bpno+1, type, cblksty);
 					break;
 				case 2:
-					t1_dec_clnpass(t1, w, h, bpno+1, orient, cblksty);
+					t1_dec_clnpass(t1, bpno+1, orient, cblksty);
 					break;
 			}
 			
@@ -865,15 +1033,15 @@
 static void t1_init_luts(opj_t1_t *t1) {
 	int i, j;
 	double u, v, t;
-	for (j = 0; j < 4; j++) {
+	for (j = 0; j < 4; ++j) {
 		for (i = 0; i < 256; ++i) {
 			t1->lut_ctxno_zc[(j << 8) | i] = t1_init_ctxno_zc(i, j);
 		}
 	}
-	for (i = 0; i < 256; i++) {
+	for (i = 0; i < 256; ++i) {
 		t1->lut_ctxno_sc[i] = t1_init_ctxno_sc(i << 4);
 	}
-	for (j = 0; j < 2; j++) {
+	for (j = 0; j < 2; ++j) {
 		for (i = 0; i < 2048; ++i) {
 			t1->lut_ctxno_mag[(j << 11) + i] = t1_init_ctxno_mag((j ? T1_REFINE : 0) | i);
 		}
@@ -883,7 +1051,7 @@
 	}
 	/* FIXME FIXME FIXME */
 	/* fprintf(stdout,"nmsedec luts:\n"); */
-	for (i = 0; i < (1 << T1_NMSEDEC_BITS); i++) {
+	for (i = 0; i < (1 << T1_NMSEDEC_BITS); ++i) {
 		t = i / pow(2, T1_NMSEDEC_FRACBITS);
 		u = t;
 		v = t - 1.5;
@@ -910,24 +1078,41 @@
 
 /* ----------------------------------------------------------------------- */
 
-opj_t1_t* t1_create(opj_common_ptr cinfo) {
-	opj_t1_t *t1 = (opj_t1_t*)opj_malloc(sizeof(opj_t1_t));
-	if(t1) {
+opj_t1_t* t1_create(opj_common_ptr cinfo){
+	opj_t1_t *t1=(opj_t1_t*)opj_malloc(sizeof(opj_t1_t));
+
+	if(t1){
 		t1->cinfo = cinfo;
 		/* create MQC and RAW handles */
 		t1->mqc = mqc_create();
 		t1->raw = raw_create();
 		/* initialize the look-up tables of the Tier-1 coder/decoder */
 		t1_init_luts(t1);
+
+#ifdef DYNAMIC_T1
+		t1->w=0;
+		t1->h=0;
+		t1->datasize=0;
+		t1->data=NULL;
+		t1->flagssize=0;
+		t1->flags=NULL;
+		assure_buffers(t1,64,64);
+#endif
 	}
+
 	return t1;
 }
 
-void t1_destroy(opj_t1_t *t1) {
-	if(t1) {
+void t1_destroy(opj_t1_t *t1){
+	if(t1){
 		/* destroy MQC and RAW handles */
 		mqc_destroy(t1->mqc);
 		raw_destroy(t1->raw);
+
+#ifdef DYNAMIC_T1
+		opj_free(t1->data);
+		opj_free(t1->flags);
+#endif
 		opj_free(t1);
 	}
 }
@@ -937,20 +1122,20 @@
 
 	tile->distotile = 0;		/* fixed_quality */
 
-	for (compno = 0; compno < tile->numcomps; compno++) {
+	for (compno = 0; compno < tile->numcomps; ++compno) {
 		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
 
-		for (resno = 0; resno < tilec->numresolutions; resno++) {
+		for (resno = 0; resno < tilec->numresolutions; ++resno) {
 			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
 
-			for (bandno = 0; bandno < res->numbands; bandno++) {
+			for (bandno = 0; bandno < res->numbands; ++bandno) {
 				opj_tcd_band_t *band = &res->bands[bandno];
 
-				for (precno = 0; precno < res->pw * res->ph; precno++) {
+				for (precno = 0; precno < res->pw * res->ph; ++precno) {
 					opj_tcd_precinct_t *prc = &band->precincts[precno];
 
-					for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-						int x, y, w, i, j, orient;
+					for (cblkno = 0; cblkno < prc->cw * prc->ch; ++cblkno) {
+						int x, y, w, i, j, orient, cblk_w, cblk_h;
 						opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
 
 						x = cblk->x0 - band->x0;
@@ -963,19 +1148,22 @@
 							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
 							y += pres->y1 - pres->y0;
 						}
-						
+
+						cblk_w=cblk->x1 - cblk->x0;
+						cblk_h=cblk->y1 - cblk->y0;
+
 						w = tilec->x1 - tilec->x0;
 						if (tcp->tccps[compno].qmfbid == 1) {
-							for (j = 0; j < cblk->y1 - cblk->y0; j++) {
-								for (i = 0; i < cblk->x1 - cblk->x0; i++) {
-									t1->data[j][i] = 
+							for (j = 0; j < cblk_h; ++j) {
+								for (i = 0; i < cblk_w; ++i) {
+									MACRO_t1_data(j,i) = 
 										tilec->data[(x + i) + (y + j) * w] << T1_NMSEDEC_FRACBITS;
 								}
 							}
 						} else {		/* if (tcp->tccps[compno].qmfbid == 0) */
-							for (j = 0; j < cblk->y1 - cblk->y0; j++) {
-								for (i = 0; i < cblk->x1 - cblk->x0; i++) {
-									t1->data[j][i] = 
+							for (j = 0; j < cblk_h; ++j) {
+								for (i = 0; i < cblk_w; ++i) {
+									MACRO_t1_data(j,i) = 
 										fix_mul(
 										tilec->data[x + i + (y + j) * w],
 										8192 * 8192 / ((int) floor(band->stepsize * 8192))) >> (13 - T1_NMSEDEC_FRACBITS);
@@ -1001,20 +1189,20 @@
 void t1_decode_cblks(opj_t1_t *t1, opj_tcd_tile_t *tile, opj_tcp_t *tcp) {
 	int compno, resno, bandno, precno, cblkno;
 
-	for (compno = 0; compno < tile->numcomps; compno++) {
+	for (compno = 0; compno < tile->numcomps; ++compno) {
 		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
 
-		for (resno = 0; resno < tilec->numresolutions; resno++) {
+		for (resno = 0; resno < tilec->numresolutions; ++resno) {
 			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
 
-			for (bandno = 0; bandno < res->numbands; bandno++) {
+			for (bandno = 0; bandno < res->numbands; ++bandno) {
 				opj_tcd_band_t *band = &res->bands[bandno];
 
-				for (precno = 0; precno < res->pw * res->ph; precno++) {
+				for (precno = 0; precno < res->pw * res->ph; ++precno) {
 					opj_tcd_precinct_t *prc = &band->precincts[precno];
 
-					for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-						int x, y, w, i, j, orient;
+					for (cblkno = 0; cblkno < prc->cw * prc->ch; ++cblkno) {
+						int x, y, w, i, j, orient, cblk_w, cblk_h;
 						opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
 
 						orient = band->bandno;	/* FIXME */
@@ -1036,16 +1224,19 @@
 							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
 							y += pres->y1 - pres->y0;
 						}
-						
+
+						cblk_w=cblk->x1 - cblk->x0;
+						cblk_h=cblk->y1 - cblk->y0;
+
 						if (tcp->tccps[compno].roishift) {
 							int thresh = 1 << tcp->tccps[compno].roishift;
-							for (j = 0; j < cblk->y1 - cblk->y0; j++) {
-								for (i = 0; i < cblk->x1 - cblk->x0; i++) {
-									int val = t1->data[j][i];
+							for (j = 0; j < cblk_h; ++j) {
+								for (i = 0; i < cblk_w; ++i) {
+									int val = MACRO_t1_data(j,i);
 									int mag = int_abs(val);
 									if (mag >= thresh) {
 										mag >>= tcp->tccps[compno].roishift;
-										t1->data[j][i] = val < 0 ? -mag : mag;
+										MACRO_t1_data(j,i) = val < 0 ? -mag : mag;
 									}
 								}
 							}
@@ -1053,20 +1244,21 @@
 						
 						w = tilec->x1 - tilec->x0;
 						if (tcp->tccps[compno].qmfbid == 1) {
-							for (j = 0; j < cblk->y1 - cblk->y0; j++) {
-								for (i = 0; i < cblk->x1 - cblk->x0; i++) {
-									tilec->data[x + i + (y + j) * w] = t1->data[j][i]/2;
+							for (j = 0; j < cblk_h; ++j) {
+								for (i = 0; i < cblk_w; ++i) {
+									tilec->data[x + i + (y + j) * w] = MACRO_t1_data(j,i)/2;
 								}
 							}
 						} else {		/* if (tcp->tccps[compno].qmfbid == 0) */
-							for (j = 0; j < cblk->y1 - cblk->y0; j++) {
-								for (i = 0; i < cblk->x1 - cblk->x0; i++) {
-									if (t1->data[j][i] >> 1 == 0) {
-										tilec->data[x + i + (y + j) * w] = 0;
+							for (j = 0; j < cblk_h; ++j) {
+								for (i = 0; i < cblk_w; ++i) {
+									int index=(x + i + (y + j) * w);
+									if (MACRO_t1_data(j,i) >> 1 == 0) {
+										tilec->data[index] = 0;
 									} else {
-										double tmp = (double)((t1->data[j][i] << 12) * band->stepsize);
+										double tmp = (double)((MACRO_t1_data(j,i) << 12) * band->stepsize);
 										int tmp2 = ((int) (floor(fabs(tmp)))) + ((int) floor(fabs(tmp*2))%2);
-										tilec->data[x + i + (y + j) * w] = ((tmp<0)?-tmp2:tmp2);
+										tilec->data[index] = ((tmp<0)?-tmp2:tmp2);
 									}
 								}
 							}
diff -ur OpenJPEG.orig/libopenjpeg/t1.h OpenJPEG/libopenjpeg/t1.h
--- OpenJPEG.orig/libopenjpeg/t1.h	2007-01-23 05:41:16.000000000 -0600
+++ OpenJPEG/libopenjpeg/t1.h	2007-03-29 20:04:12.000000000 -0500
@@ -44,8 +44,14 @@
 /* ----------------------------------------------------------------------- */
 #define T1_NMSEDEC_BITS 7
 
-#define T1_MAXCBLKW 1024	/**< Maximum size of code-block (width) */
-#define T1_MAXCBLKH 1024	/**< Maximum size of code-block (heigth) */
+#ifndef DYNAMIC_T1
+// Yes, this is likely an slviewer specific performance tweak
+#define T1_MAXCBLKW 64       /**< Maximum size of code-block (width) */
+#define T1_MAXCBLKH 64       /**< Maximum size of code-block (heigth) */
+
+	//define T1_MAXCBLKW 1024       /**< Maximum size of code-block (width) */
+	//define T1_MAXCBLKH 1024       /**< Maximum size of code-block (heigth) */
+#endif
 
 #define T1_SIG_NE 0x0001	/**< Context orientation : North-East direction */
 #define T1_SIG_SE 0x0002	/**< Context orientation : South-East direction */
@@ -109,11 +115,27 @@
 	int lut_nmsedec_ref[1 << T1_NMSEDEC_BITS];
 	int lut_nmsedec_ref0[1 << T1_NMSEDEC_BITS];
 
+	int w;
+	int h;
+#ifdef DYNAMIC_T1
+	size_t datasize;
+	int *data;
+	size_t flagssize;
+	int *flags;
+#else
 	int data[T1_MAXCBLKH][T1_MAXCBLKW];
 	int flags[T1_MAXCBLKH + 2][T1_MAXCBLKH + 2];
-
+#endif
 } opj_t1_t;
 
+#ifdef DYNAMIC_T1
+#	define MACRO_t1_data(x,y) t1->data[((x)*(t1->w))+(y)]
+#	define MACRO_t1_flags(x,y) t1->flags[((x)*((t1->h)+2))+(y)]
+#else
+#	define MACRO_t1_data(x,y) t1->data[(x)][(y)]
+#	define MACRO_t1_flags(x,y) t1->flags[(x)][(y)]
+#endif
+
 /** @name Exported functions */
 /*@{*/
 /* ----------------------------------------------------------------------- */
